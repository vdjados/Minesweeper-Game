section '.data' writable
    f db "/dev/urandom",0  ; Строка с путём к файлу /dev/urandom, заканчивается нулём

; Секция неинициализированных данных
section '.bss' writable
    random_number rq 1   ; Резервируем 8 байт (quad-word) для хранения числа
    place rb 100  ; Резервируем 100 байт для строкового буфера


generate_number:
    ; Открываем файл /dev/urandom
    mov rdi, f      ; 1-й аргумент: указатель на имя файла
    mov rax, 2      ; Номер системного вызова open()
    mov rsi, 0      ; 2-й аргумент: флаги (0 = только чтение)
    syscall         ; Вызываем ядро
    
    ; Проверяем результат открытия файла
    cmp rax, 0      ; Сравниваем возвращаемый дескриптор с 0
    jl .l1          ; Если ошибка (отрицательное число), переходим к завершению
    
    ; Сохраняем файловый дескриптор в r8
    mov r8, rax

    ; Читаем данные из файла
    mov rax, 0      ; Номер системного вызова read()
    mov rdi, r8     ; 1-й аргумент: файловый дескриптор
    mov rsi, random_number ; 2-й аргумент: буфер для чтения (random_number)
    mov rdx, 1      ; 3-й аргумент: количество байт для чтения (1 байт)
    syscall         ; Вызываем ядро
    

    ; Преобразуем число в строку
    mov rax, [random_number]
    xor rdx, rdx        ; Обнуляем rdx перед делением
    mov rcx, 100        ; Верхняя граница
    div rcx             ; rdx = rax % 100 (остаток от деления)
    mov rax, rdx

    mov rsi, place    ; Указываем буфер для строки (place)
    call number_str   ; Вызываем функцию преобразования
    
    ; Выводим строку
    ;call print_str    ; Выводим строку из place
    ;call new_line     ; Переводим строку
    
    ; Закрываем файл
    mov rax, 3      ; Номер системного вызова close()
    mov rdi, r8     ; 1-й аргумент: файловый дескриптор
    syscall         ; Вызываем ядро

; Метка для обработки ошибок и завершения
.l1:
    ret